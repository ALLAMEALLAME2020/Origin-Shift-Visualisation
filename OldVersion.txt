import pygame
import sys
import random
import time
from colorama import Fore, init, Style
init(autoreset=True)

pygame.init() # Initialisation (Get ready for work hehe)

# Varibles
screen_x, screen_y = 600, 600
celle_size = 40
screen = pygame.display.set_mode((screen_x, screen_y))
pygame.display.set_caption("Origin Shift Visualisation")
clock = pygame.time.Clock()
Running = True
colors_root = {
    "background-color": (27, 26, 23),
    "walls-color": (230, 213, 184),
    "lines-color": (50, 50, 50),
    "path-color": (242, 255, 0, 0.8)
}

paths = set()
Use_blocks = True
Use_lines = False

screen.fill((colors_root["background-color"])) # Background color

while Running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT: # Closing window Event
            Running = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q: # Closing window Event Using (Q Button)
                Running = False
                
            if event.key == pygame.K_m: # Saving the map cells in file to use lmra jaya
                try:
                    with open('PathData.txt','w') as file: # Write data on the file (Anl9ah fsame path kola mra hehe)
                        file.write(str(paths))
                        print(Fore.GREEN+Style.BRIGHT+f"Map god saved in the file Succsusfully")
                    pass
                except Exception as e: # Detect Errors
                    print(Fore.RED+Style.BRIGHT+f"Error Detected  : {e}")

            if event.key == pygame.K_c: # Clear the MAP (msa7 msa7)
                print(Fore.GREEN+Style.BRIGHT+f"Map hase been cleard !!")
                paths = set() # Clear the list of paths
                screen.fill((colors_root["background-color"])) # Recolor the Background


            # Make the clicks draw cells (blocks) ( moraba3at minecraft hehee)
            if event.key == pygame.K_z: 
                Use_blocks, Use_lines = True, False # ----> Blocks : True
            if event.key == pygame.K_x:
                Use_blocks, Use_lines = False, True # ----> Lines : True
                



    mouse = pygame.mouse.get_pressed() # Mouse Events hoohoo !!
    mouse_pose = pygame.mouse.get_pos() # Mouse [X, Y] cordinateS
    if mouse:
        if mouse_pose[0] > screen_x or mouse_pose[0] < 0 or mouse_pose[1] > screen_y or mouse_pose[1] < 0:
            pass
        else:
            if mouse[0]:
                blockPos_X = int(mouse_pose[0] / celle_size) # X cell Cordinates
                blockPos_Y = int(mouse_pose[1] / celle_size) # Y cell Cordinates
                DrawingCells(blockPos_X, blockPos_Y) # Drawing a cell
                
                print(Fore.BLUE+Style.BRIGHT+f"Left Mouse got pressed --> [ X: {Fore.GREEN+str(blockPos_X)+Fore.BLUE}, Y: {Fore.GREEN+str(blockPos_Y)+Fore.BLUE} ]")
            elif mouse[2]:
                blockPos_X = int(mouse_pose[0] / celle_size) # X cell Cordinates
                blockPos_Y = int(mouse_pose[1] / celle_size) # Y cell Cordinates
                RemovingCells(blockPos_X, blockPos_Y) # Drawing a cell
                
                pass
    
    
    # Functions [Drawning / Removing]
    def DrawingCells(cell_x, cell_y):
        cell_pos = cell_x, cell_y
        if cell_pos in paths:
            pass
        else:
            paths.add(cell_pos)
            neighbors = [ # Searching for authers dotes bach ytconectaw wkda rak fahm
                [cell_x - 1, cell_y], # Left
                [cell_x + 1, cell_y], # Right
                [cell_x, cell_y + 1], # Down
                [cell_x, cell_y - 1] # Top
            ]
            
            
            if Use_lines:
                for neb in neighbors:
                    if tuple(neb) in paths:
                        pygame.draw.line(screen, colors_root["path-color"], ((cell_x * celle_size) + celle_size / 2,(cell_y * celle_size) + celle_size / 2), ((neb[0] * celle_size) + celle_size / 2, (neb[1] * celle_size) + celle_size / 2), 2)
                        pass
                pygame.draw.circle(screen, colors_root["walls-color"], ((cell_x * celle_size) + celle_size / 2, (cell_y * celle_size) + celle_size / 2), 2)
            
            elif Use_blocks:
                pygame.draw.rect(screen, colors_root["walls-color"], ((cell_x * celle_size), (cell_y * celle_size), celle_size, celle_size))
                
            print(paths)
    
    
    # Removing Cells function.
    def RemovingCells(cell_x, cell_y):
        cell_pos = cell_x, cell_y
        if cell_pos in paths:
            paths.remove(cell_pos)
            pygame.draw.rect(screen, colors_root["background-color"], ((cell_x * celle_size), (cell_y * celle_size), celle_size, celle_size))
        else:
            pass
    
    

    
    # (X, Y) lines drawning
    for x in range(0, screen_x, celle_size): # (X) lines Rows
        pygame.draw.line(screen, colors_root["lines-color"], (x, 0), (x, screen_y))
    
    for y in range(0, screen_y, celle_size): # (Y) lines Columns
        pygame.draw.line(screen, colors_root["lines-color"], (0, y), (screen_x, y))
    
    pygame.display.update()
    clock.tick(60)
    pass